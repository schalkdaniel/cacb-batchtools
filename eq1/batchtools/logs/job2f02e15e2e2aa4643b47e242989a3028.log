### [bt]: This is batchtools v0.9.15
### [bt]: Starting calculation of 1 jobs
### [bt]: Setting working directory to '/home/user/repos/cacb-batchtools/eq1'
[2021-07-28 22:44:19] Loading new learner
[2021-07-28 22:44:19] Loading tasks
[2021-07-28 22:44:21] Loading resampling
### [bt]: Memory measurement disabled
### [bt]: Starting job [batchtools job.id=93]
### [bt]: Generating problem instance for problem '168908-fold4' ...
### [bt]: Applying algorithm 'evaluate-learner' on problem '168908-fold4' for job 93 (seed = 31508) ...
DEBUG [22:44:22.770] [mlr3]  Skip subsetting of task 'Task 168908: christine (Supervised Classification)' 
DEBUG [22:44:22.775] [mlr3]  Calling train method of Learner 'bin_cwb_nb' on task 'Task 168908: christine (Supervised Classification)' with 4334 observations {learner: <LearnerClassifCompboost/LearnerClassif/Learner/R6>}

39: (function (e) 
    traceback(2L))()
38: as.matrix.data.frame(data_columns)
37: as.matrix(data_columns)
36: new_CppObject_xp(fields$.module, fields$.pointer, ...)
35: Rcpp::cpp_object_initializer(.self, .refClassDef, ...)
34: .Object$initialize(...)
33: initialize(value, ...)
32: initialize(value, ...)
31: methods::new(def, ...)
30: data_source$new(as.matrix(data_columns), paste(feature, collapse = "_"))
29: private$addSingleNumericBl(data_columns, feature, id, id_fac, 
        bl_factory, data_source, ...)
28: model$addBaselearner(feat, "spline", BaselearnerPSpline, data_source, 
        degree = degree, n_knots = n_knots, penalty = penalty, df = df, 
        differences = differences, bin_root = bin_root, bin_method = bin_method, 
        cache_type = cache_type)
27: compboost::boostSplines(data = task$data(), target = task$target_names, 
        iterations = self$param_set$values$mstop, optimizer = optimizer, 
        loss = compboost::LossBinomial$new(), df = self$param_set$values$df, 
        learning_rate = self$param_set$values$learning_rate, oob_fraction = oobf, 
        stop_args = stop_args, bin_root = self$param_set$values$bin_root, 
        bin_method = self$param_set$values$bin_method, df_cat = self$param_set$values$df_cat, 
        additional_risk_log = additional_risk_log)
26: get_private(learner)$.train(task)
25: .f(learner = <environment>, task = <environment>)
24: eval(expr, p)
23: eval(expr, p)
22: eval.parent(expr, n = 1L)
21: invoke(.f, .args = .args, .opts = .opts, .seed = .seed, .timeout = .timeout)
20: encapsulate(learner$encapsulate["train"], .f = train_wrapper, 
        .args = list(learner = learner, task = task), .pkgs = learner$packages, 
        .seed = NA_integer_, .timeout = learner$timeout["train"])
19: learner_train(self, task, row_ids)
18: .__Learner__train(self = self, private = private, super = super, 
        task = task, row_ids = row_ids)
17: learner$train(task_train) at add-experiments.R#52
16: job$algorithm$fun(job = job, data = job$problem$data, instance = instance, 
        ...)
15: (function (...) 
    job$algorithm$fun(job = job, data = job$problem$data, instance = instance, 
        ...))(lid = "bin_cwb_nb")
14: do.call(wrapper, job$algo.pars, envir = .GlobalEnv)
13: with_preserve_seed({
        set.seed(seed)
        code
    })
12: with_seed(job$seed, do.call(wrapper, job$algo.pars, envir = .GlobalEnv))
11: execJob.Experiment(job)
10: execJob(job)
9: doTryCatch(return(expr), name, parentenv, handler)
8: tryCatchOne(expr, names, parentenv, handlers[[1L]])
7: tryCatchList(expr, classes, parentenv, handlers)
6: tryCatch(expr, error = function(e) {
       call <- conditionCall(e)
       if (!is.null(call)) {
           if (identical(call[[1L]], quote(doTryCatch))) 
               call <- sys.call(-4L)
           dcall <- deparse(call)[1L]
           prefix <- paste("Error in", dcall, ": ")
           LONG <- 75L
           sm <- strsplit(conditionMessage(e), "\n")[[1L]]
           w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")
           if (is.na(w)) 
               w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
                   type = "b")
           if (w > LONG) 
               prefix <- paste0(prefix, "\n  ")
       }
       else prefix <- "Error : "
       msg <- paste0(prefix, conditionMessage(e), "\n")
       .Internal(seterrmessage(msg[1L]))
       if (!silent && isTRUE(getOption("show.error.messages"))) {
           cat(msg, file = outFile)
           .Internal(printDeferredWarnings())
       }
       invisible(structure(msg, class = "try-error", condition = e))
   })
5: try(execJob(job))
4: doJobCollection.JobCollection(jc, output = jc$log.file)
3: doJobCollection(jc, output = jc$log.file)
2: reg$cluster.functions$submitJob(reg = reg, jc = jc)
1: submitJobs(findNotDone())
